# Implementation architecture: layers and interface contracts

## 1. Goals

This architecture must satisfy:

- **Parallelizable development**: environments, agent core, genome compiler, evolution engine can be developed by different people with minimal coordination.
- **JAX-first efficiency**: end-to-end evaluation should be compatible with `jit`, `vmap`, and `lax.scan`.
- **Reproducibility**: deterministic PRNG handling, logged manifests, and replayability.
- **Experimental flexibility**: strains, nursing, pruning, and evaluator tiers must be toggles, not rewrites.

---

## 2. Layered architecture overview

```
L7  Experiment Ops (configs, manifests, checkpoints)
L6  Observability & Analysis (metrics, dashboards)
L5  Evolution Engine (ask-eval-tell, multi-fidelity budgets)
L4  Simulation Orchestrator (agent×env rollouts, lifetime evaluation)
L3  Genome & Development Compiler (genotype→phenotype)
L2  Agent Core (neural substrate, plasticity kernel)
L1  Environment Engine (state transition, observations, internal state)
L0  Runtime Core (PRNG, config, logging primitives)
```

Rule: Each layer depends only on layers below it via explicit interfaces.

---

## 3. Core types (shared schemas)

### 3.1 EnvSpec / EnvState / EnvObservation

- `EnvSpec`: static parameters describing a level instance (layout seed, resource densities, hazard schedule)
- `EnvState`: dynamic world state (resources remaining, agent pose, hazard states)
- `EnvObservation`: observation vector(s) provided to agent

### 3.2 InternalState

Internal viability variables:

- energy, integrity (always)
- additional variables added by environment level

### 3.3 AgentParams / AgentState / Action

- `AgentParams`: static phenotype parameters generated by development
  - neuron parameters, sparse edges, plasticity rule coefficients, modulatory readout mappings
- `AgentState`: dynamic neural state + plasticity traces
- `Action`: motor commands and optional action channels (consume, rest)

### 3.4 DevelopmentState

- `age_step`, `phi` plus optional developmental flags
- passed to both env and agent each step

### 3.5 Genome

A PyTree representing CPPN and rule networks (and optional NEAT topology state).

---

## 4. Interface contracts

### 4.1 Environment Engine interface

- `env_init(spec: EnvSpec, rng) -> (EnvState, EnvObservation, InternalState)`
- `env_step(state: EnvState, action: Action, dev: DevelopmentState, rng) -> (EnvState, EnvObservation, InternalState, EnvLog, done)`

Notes:
- reward is **not** returned; reward is computed from internal state via drive reduction in the orchestrator.

### 4.2 Agent Core interface

- `agent_init(params: AgentParams, rng) -> AgentState`
- `agent_step(params: AgentParams, state: AgentState, obs: EnvObservation, internal: InternalState, dev: DevelopmentState, rng) -> (AgentState, Action, AgentLog)`

Notes:
- agent core implements neural dynamics and within-life plasticity.
- agent core must be pure and JAX-transformable.

### 4.3 Genome compiler interface

- `develop(genome: Genome, dev_cfg, rng) -> AgentParams`

Optional:
- `genome_init(gen_cfg, rng) -> Genome`
- `genome_mutate(genome, mut_cfg, rng) -> Genome`

### 4.4 Simulation Orchestrator interface

- `simulate_lifetime(genome, env_spec, dev_cfg, sim_cfg, rng) -> (FitnessSummary, TrajectorySummary)`
- `simulate_mvt(genome, nursery_env_spec, dev_cfg, mvt_cfg, rng) -> ViabilityResult`

Implementation should use:
- `lax.scan` over time
- `vmap` over population

### 4.5 Evolution Engine interface

- `evaluate_population(pop_genomes, env_spec, ..., rng) -> FitnessBatch`
- `evolve_step(pop_genomes, fitness_batch, evo_state, rng) -> (new_pop, new_state)`

The evolution engine owns:
- multi-fidelity promotion policy,
- nursing/pruning integration,
- novelty archive integration (optional).

---

## 5. Observability hooks

### 5.1 Online logs (low overhead)

At most a few scalars per step/episode:

- survival time, resources acquired
- average spike rate (if spiking)
- modulatory signal statistics
- plasticity magnitude statistics

### 5.2 Offline trajectories (sampled)

Save only a small fraction of episodes for rich analysis:

- full observation/action/internal traces
- selected neural activity traces (subset of neurons)
- weight update statistics

---

## 6. Reproducibility requirements

Every run produces a manifest including:

- git commit hash (or file hash snapshot),
- all configs (env, dev, sim, evo),
- PRNG master seed and derived stream strategy,
- hardware info (device types, XLA flags if relevant).

Replays should be supported by:

- deterministic env generation given seed,
- deterministic development given genome and seed,
- deterministic simulation given all seeds.

---

## 7. Parallel work decomposition

### Team A — Environment

- implement EnvSpec/EnvState dynamics for ladder levels
- provide baseline agents for sanity tests

### Team B — Agent core

- implement neural dynamics and plasticity kernel
- ensure stable and fast `jit` + `scan`

### Team C — Genome compiler

- implement development pipeline and mutation operators

### Team D — Evolution and ops

- integrate evosax strategies, multi-fidelity budgets, checkpointing
- logging and experiment orchestration

### Team E — Analysis

- dashboards, emergence detection tests, cross-strain comparisons

---

## 8. Deliverables

- Stable interface definitions and schemas.
- Reference implementations/stubs for each interface.
- Integration tests for end-to-end evaluation on L0 environments.
